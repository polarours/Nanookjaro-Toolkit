# Nanookjaro 架构 🏗️

## 概述 🌟

Nanookjaro 工具包采用优雅的模块化架构，后端（C++ 核心）、前端（Flutter GUI）和命令行界面之间有明确的分离。这种精巧的设计实现了最大的代码重用、可维护性和可扩展性，同时确保了一致的系统监控和管理体验。

该架构采用渐进式增强的方法构建，优先考虑 Linux 发行版（特别是基于 Arch 的发行版），同时为未来的平台扩展（包括 macOS）奠定了基础。

## 高级架构 📐

```
┌────────────────────────────────────────────────────────┐
│                     前端层                             │
│                                                        │
│              ┌─────────────────────────┐               │
│              │    Flutter 桌面应用      │               │
│              │   玻璃态 UI/UX 设计      │               │
│              └─────────────────────────┘               │
│                                                        │
│              ┌─────────────────────────┐               │
│              │      CLI 接口           │               │
│              │   终端优化设计          │               │
│              └─────────────────────────┘               │
└──────────────────────────┬─────────────────────────────┘
                           │ FFI 桥接 (JSON)
┌──────────────────────────┴─────────────────────────────┐
│                     中间件层                           │
│                                                        │
│              ┌─────────────────────────┐               │
│              │    C++ 核心库           │               │
│              │    (Nanookjaro 核心)    │               │
│              └─────────────────────────┘               │
│                   系统信息                             │
│                   包管理                               │
│                   性能指标                             │
│                   数据导入/导出                        │
└──────────────────────────┬─────────────────────────────┘
                           │ 平台抽象层
┌──────────────────────────┴─────────────────────────────┐
│                     平台层                             │
│                                                        │
│  Linux (主要)    macOS (计划中)    Windows (未来)      │
│  /proc, sysfs    IOKit                                 │
│  lspci, lsmod    sysctl                                │
│  udev, smartctl  system_profiler                       │
│  pacman (pacman)                                       │
└────────────────────────────────────────────────────────┘
```

## 项目结构 📁

```
.
├── backend/               # C++ 后端实现
│   ├── src/              # 源代码
│   │   ├── hardware/     # 硬件监控模块
│   │   ├── network/      # 网络监控模块
│   │   ├── system/       # 系统信息模块
│   │   ├── maintenance/  # 维护和包管理
│   │   ├── drivers/      # 驱动管理
│   │   ├── performance/  # 性能监控
│   │   ├── ffi.cpp       # FFI 接口实现
│   │   └── ...           # 其他模块
│   ├── include/          # 公共头文件
│   └── CMakeLists.txt    # 构建配置
├── frontend/             # 前端
│   └── flutter/          # Flutter 应用程序
├── cli/                  # 命令行界面
├── docs/                 # 文档
├── cmake/                # CMake 模块
├── scripts/              # 构建和工具脚本
└── CMakeLists.txt        # 根构建配置
```

## 组件详情 🧩

### 后端（C++ 核心）⚙️

后端使用现代 C++（C++20）实现，提供核心功能：

1. **系统信息模块**
   - CPU 监控（使用率、频率、温度）
   - 内存监控（RAM、交换区）
   - 磁盘监控（使用情况、SMART 数据）
   - GPU 监控（使用率、温度）
   - 网络监控（带宽、连接）
   - 进程监控

2. **包管理模块**
   - 与系统包管理器集成
   - 主要支持 pacman（Arch/Manjaro）
   - 计划支持 apt（Debian/Ubuntu）和 yum/dnf（RHEL/CentOS）

3. **性能监控**
   - 实时数据采样
   - 历史数据存储在环形缓冲区中
   - 可配置的采样间隔

### 前端（Flutter GUI）🎨

前端使用 Flutter 构建，提供现代化、响应式的用户界面：

1. **UI 组件**
   - 带有关键指标的仪表板
   - 详细的系统信息视图
   - 实时性能图表
   - 包管理界面
   - 设置和配置

2. **状态管理**
   - 使用 Riverpod 进行状态管理
   - 后端的响应式更新
   - UI 交互的本地状态

### 命令行界面 💻

CLI 提供从终端访问工具包功能：

1. **命令**
   - 系统信息显示
   - 包管理操作
   - 报告生成
   - 无头操作模式

## 通信模式 🔄

### FFI 通信 🔌

Flutter 前端和 C++ 后端之间的主要通信通过 Dart FFI 进行：

1. **函数调用**
   - 用于即时数据的同步调用
   - 用于长时间运行操作的异步调用

2. **数据交换**
   - 用于复杂数据结构的 JSON 字符串
   - 用于标量数据的简单值
   - 通过显式分配/释放进行内存管理

## 数据流 📊

1. **数据收集**
   - 后端从系统 API 收集数据
   - 数据被处理并格式化为 JSON
   - 数据存储在环形缓冲区中以供历史访问

2. **数据分发**
   - 前端通过 FFI 请求数据
   - CLI 通过直接库调用访问数据

3. **实时更新**
   - 后端向注册的监听器推送更新
   - 前端以可配置的间隔轮询更新
   - CLI 可以订阅流式更新